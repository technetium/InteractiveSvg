
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
</head>
<body>

https://eloquentjavascript.net/15_event.html
http://tutorials.jenkov.com/svg/svg-and-css.html
https://help.github.com/articles/what-is-github-pages/
https://rawgit.com/technetium/InteractiveSvg/master/canvas.html
https://tympanus.net/codrops/2015/07/16/styling-svg-use-content-css/

<style>
	svg.tc_svg_edit .node { 
		opacity: 0.1;
		r: 10;
	}
	svg.tc_svg_edit:hover .node { 
		opacity: 0.5;
	}
	svg.tc_svg_edit:hover .node:hover { 
		cursor: move;
		opacity: 1;
	}
</style>
<script>
	console.log("script");

	class TcSvgEdit {
	
		constructor(prefix) {
			console.log("construct");
			
			TcSvgEdit.node_circle_radius = 5;
			TcSvgEdit.node_cross_radius = 11;
			TcSvgEdit.node_fill = '#EEF';
			TcSvgEdit.node_stroke = '#00F';
			
			TcSvgEdit.prefix = "tc_svg_edit_";
			TcSvgEdit.namespace_svg = "http://www.w3.org/2000/svg";
			TcSvgEdit.namespace_xlink = "http://www.w3.org/1999/xlink";
			
			if ("undefined" !== typeof prefix) { TcSvgEdit.prefix = prefix; }
			document.addEventListener("mousedown", function(event){
				TcSvgEdit.onMouseDown(event);
			});
			document.addEventListener("mousemove", function(event){
				TcSvgEdit.onMouseMove(event);
			});
			document.addEventListener("mouseup", function(event){
				TcSvgEdit.onMouseUp(event);
			});
		}

		//
		// Getters
		//
		
		static getDefs(svg) {
			let defs = svg.querySelector("defs");
			if (!defs)	{
				defs = TcSvgEdit.initDefs(svg);
			}
			return defs;
		}
		
		static getId(svg) {
			if (!svg.hasAttribute("id")) {
				TcSvgEdit.initSvgId(svg);
			}
			return svg.getAttribute("id");
		}
		
		static getNode(svg) {
			console.log("getNode");
			let node = document.getElementById(TcSvgEdit.idNode(svg));
			if (!node)	{
				node = TcSvgEdit.initNode(svg);
			}
			console.log(node);
			return node;
		}

		//
		// Id's
		//
		static idNode(svg) { return	TcSvgEdit.getId(svg) + '-symbol-node'; }

		//
		// Initialisers
		//

		static initDefs(svg) {
			console.log('initDefs');
			let defs = TcSvgEdit.createSvgElement("defs");
			svg.append(defs);
			return defs;
		}
		
		static initNode(svg) {
			console.log('initNode');
			let defs = TcSvgEdit.getDefs(svg);
			let node = TcSvgEdit.createSvgElement("symbol");
			node.setAttribute("id", TcSvgEdit.idNode(svg));
			node.classList.add("node");
			node.setAttribute("fill", TcSvgEdit.node_fill);
			node.setAttribute("stroke", TcSvgEdit.node_stroke);
			

			// The size of the node
			let s = Math.max(
				TcSvgEdit.node_cross_radius,
				TcSvgEdit.node_circle_radius
			);
	
			// inatialise element
			let e = null; 

			// Circle
			e = TcSvgEdit.createSvgElement("circle");
			e.setAttribute("cx", s);
			e.setAttribute("cy", s);
			e.setAttribute("r", TcSvgEdit.node_circle_radius);
			node.append(e);
			
			// Horizontal cross hair
			e = TcSvgEdit.createSvgElement("line");
			e.setAttribute("x1", s - TcSvgEdit.node_cross_radius);
			e.setAttribute("y1", s);
			e.setAttribute("x2", s + TcSvgEdit.node_cross_radius);
			e.setAttribute("y2", s);
			node.append(e);

			// Vertical cross hair
			e = TcSvgEdit.createSvgElement("line");
			e.setAttribute("x1", s);
			e.setAttribute("y1", s - TcSvgEdit.node_cross_radius);
			e.setAttribute("x2", s);
			e.setAttribute("y2", s + TcSvgEdit.node_cross_radius);
			node.append(e);

			node.setAttribute("transform", "translate(-"+s+", -"+s+")");
			defs.append(node);
			return node;
		}
		
		static initSvgId(svg) {
			svg.setAttribute(
				"id",
				TcSvgEdit.prefix + '_id_' +
				//@see https://stackoverflow.com/questions/1349404/generate-random-string-characters-in-javascript
				Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5)
			);
		}
		
		//
		// Event Listeners
		//
		
		static onMouseDown(event) {
			//console.log("TcSvgEdit.onMouseDown");
			//console.log(event);
			TcSvgEdit.svgOnMouseDown(event);
		}
		
		static onMouseMove(event) {
			///console.log("TcSvgEdit.onMouseMove");
			///console.log(event);
			TcSvgEdit.svgOnMouseMove(event);
		}

		static onMouseUp(event) {
			//console.log("TcSvgEdit.onMouseUp");
			//console.log(event);
			TcSvgEdit.svgOnMouseUp(event);
		}

		//
		// node
		//
		
		static nodeOnMouseDrag(node, pos) {
			console.log("nodeOnMouseDrag");
			console.log(typeof node);
			console.log(pos);
			node.setAttribute("x", pos.x); 
			node.setAttribute("y", pos.y); 
		}
		
		//
		// svg
		//
		
		static svgOnMouseDown(event) {
			let svg = event.target.closest("svg.tc_svg_edit");
			if (null === svg) { return; }
			
			let node = event.target.closest(".node");
			if (null !== node) {
				console.log(node);
				svg[TcSvgEdit.prefix + "_selected"] = node;
				console.log("selected");
				console.log(svg[TcSvgEdit.prefix + "_selected"]);
				return;
			}
			
			console.log(svg);
			let pos = TcSvgEdit.utilGetSvgCoordinates(svg, event);
			console.log(pos);
			TcSvgEdit.svgAddNode(svg, pos.x, pos.y);
		}

		static svgOnMouseMove(event) {
			let svg = event.target.closest("svg.tc_svg_edit");
			if (null === svg) { return; }
			if (!svg[TcSvgEdit.prefix + "_selected"]) {
				return;
			}
			TcSvgEdit.nodeOnMouseDrag(
				svg[TcSvgEdit.prefix + "_selected"],
				TcSvgEdit.utilGetSvgCoordinates(svg, event)
			);
		}

		static svgOnMouseUp(event) {
			let svg = event.target.closest("svg.tc_svg_edit");
			if (null === svg) { return; }
			svg[TcSvgEdit.prefix + "_selected"] = null;
		}
		

		static svgAddNode(svg, x, y) {
			console.log("svgAddNode("+x+", "+y+")");
			let node = TcSvgEdit.getNode(svg);
			let u = TcSvgEdit.createSvgElement("use");
			u.classList.add("node");
			u.setAttributeNS(TcSvgEdit.namespace_xlink, "href", "#" + TcSvgEdit.idNode(svg));
			u.setAttribute("x", x);
			u.setAttribute("y", y);
			svg.append(u);
		}

		// Because I"m to lazy to type the namespace
		static createSvgElement(name) {
			return document.createElementNS(TcSvgEdit.namespace_svg, name);
		}
		
		static utilGetSvgCoordinates(svg, event) {
			console.log("utilGetSvgCoordinates()");
			// @see https://stackoverflow.com/questions/12752519/svg-capturing-mouse-coordinates
			let pt = svg.createSVGPoint();
			pt.x = event.clientX;
			pt.y = event.clientY;

			// The cursor point, translated into svg coordinates
			let cursorpt =  pt.matrixTransform(svg.getScreenCTM().inverse());
			console.log("(" + cursorpt.x + ", " + cursorpt.y + ")");
			return cursorpt;
		}		
	}

	new TcSvgEdit("someprefix");
</script>


addEventListener("click", function(){modifyText("four")}, false);

<button>Click me</button>
<button>Click me</button>
<p>No handler here.</p>
<script>
  let buttons = document.querySelectorAll("button");
	buttons.forEach(function(button) {
	///console.log(button);
	///button.addEventListener("click", onButtonClick);
});
  
  </script>


<svg version="1.1"
     xmlns:svg="http://www.w3.org/2000/svg"
     xmlns="http://www.w3.org/2000/svg"
     width="500" height="240"
	class="tc_svg_edit"
>    

    
</svg>

<svg version="1.1"
     xmlns:svg="http://www.w3.org/2000/svg"
     xmlns="http://www.w3.org/2000/svg"
     width="500" height="240"
	class="not_tc_svg_edit"
	id="svg_foo"
>
   <g transform="translate(280,100)" >
        <circle class="control_point" cx="0" cy="0" r="10"  />
        <circle class="point4 invisible" cx="0" cy="0" r="3" />
    </g>
</svg>

<svg version="1.1"
     xmlns:svg="http://www.w3.org/2000/svg"
     xmlns="http://www.w3.org/2000/svg"
     width="500" height="240"
	class="tc_svg_edit"
	id="foo"
>
   <defs>
		<symbol id="foo-symbol-node" class="node" transform="translate(-10,-10)">
			<line x1="0" y1="0" x2="20" y2="20" stroke="red" />
			<line x1="0" y1="20" x2="20" y2="0" stroke="red" />
			<circle cx="10" cy="10" r="5" stroke="green" stroke-width="1" />
		</symbol>
   </defs>
        <circle class="control_point" cx="230" cy="120" r="10" />
        <circle class="point4 invisible" cx="120" cy="120" r="3" />
</svg>

</body>
</html>